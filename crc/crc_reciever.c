#include <stdio.h>
#include <string.h>

int main(){
	int msglength, keylength, i, j;
	char data[30], key[30], tempkey[30], temp[30], quotient[30], remainder[30];
	
	// Taking input from the user for the 
	// complete data containing the CRC
	printf("Enter the data: \n");
	gets(data);

	// Taking input from the user for the
	// key or the generator that was used in
	// making the final data
	printf("Enter the key: \n");
	gets(key);

	// Creating a temporary variable which will store
	// the key that will later be used for the division purpose
	strcpy(tempkey, key);

	// Finding the length of the data and the key
	msglength = strlen(data);
	keylength = strlen(key);

	// Storing the number of bits equal to the keylength which will
	// be used to do the devision.
	// Like: If, 
	// Data: 1 0 1 0 0
	// Key : 1 1 0
	// Then,
	// Temp: 1 0 1
	for (i = 0; i < keylength; ++i)
	{
		temp[i] = data[i];
	}

	// This portion does the complete division with the generator
	// that was entered by the user. If the remainder generated by
	// these codes gives 0 then the data is all fine. Or else it is
	// having errors

	// Now the loop shoould run uptil msglength - keylength + 1
	// because the current message length includes the crc code
	// as well, so we need to do a subtraction in order to get the
	// length of the actual message length
	for (i = 0; i < msglength - keylength + 1; ++i)
	{
		// Now the quotient will actually depend on the first
		// bit that we want to divide
		// Like if we are dividing 1100 by 100 then obviously
		// the quotient will be 1 since 1 x 100 will be 100
		// and 0 x 100 will be 000, and there cant be any other
		// possibility there can only be these two possibility
		// So if the the number starts with 0 the corresponding
		// quotient should also be 0, and vice versa
		quotient[i] = key[i];

		// Now if the quotient bit is 0,
		// after multiplying with it we will get all zeros
		// in the result, and this we store all zeros in the
		// key array. Which we will use later to divide
		if (quotient[i] == '0')
		{
			for (j = 0; j < keylength; ++j)
			{
				key[j] = '0';
			}
		}

		// Now if the quotient bit is 1,
		// after multiplying with it we will get all same
		// elements. Thus we will get the same value as the entered
		// key and we retrieve that from the tempkey that we made a 
		// copy of in line number 22
		else
		{
			for (j = 0; j < keylength; ++j)
			{
				key[j] = tempkey[j];
			}
		}


		// Here we perform the subtraction operation during the
		// division which is nothing but a XOR operation
		for (j = keylength - 1; j > 0; --j)
		{
			// If the both the bits are same then 0 should be saved
			// in remainder
			if (key[j] == temp[j])
			{
				remainder[j - 1] = '0';
			}
			// If there are different bits present then 1 should be
			// stored in the remainder
			else
			{
				remainder[j - 1] = '1';
			}
		}

		// We bring down the next from the original message
		remainder[keylength - 1] = data[keylength + i];

		// The remainder is copied in the array temp again so that
		// the next division operation can be performed when the 
		// for loop rotates again
		strcpy(temp, remainder);
	}

	// Copying the final remainder from the temp variable to
	// the remainder variable
	strcpy(remainder, temp);

	printf("Remainder: \n");
	for (i = 0; i < keylength - 1; ++i)
	{
		printf("%c", remainder[i]);
	}
	printf("\n");
}